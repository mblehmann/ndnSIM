/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/**
 * Copyright (c) 2011-2015  Regents of the University of California.
 *
 * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and
 * contributors.
 *
 * ndnSIM is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Matheus Lehmann <mblehmann@inf.ufrgs.br>
 * @author Lucas Leal <lsleal@inf.ufrgs.br>
 */

#include "pdrm-strategy.hpp"

#include "utils/ndn-ns3-packet-tag.hpp"
#include "utils/ndn-fw-hop-count-tag.hpp"

#include "helper/ndn-fib-helper.hpp"

using namespace std;

NS_LOG_COMPONENT_DEFINE("ndn.PDRMStrategy");

namespace ns3 {
namespace ndn {

NS_OBJECT_ENSURE_REGISTERED(PDRMStrategy);

TypeId
PDRMStrategy::GetTypeId(void)
{
  static TypeId tid =
    TypeId("ns3::ndn::PDRMStrategy")
      .SetGroupName("Ndn")
      .SetParent<PDRMCustodian>()
      .AddConstructor<PDRMStrategy>()

      // Strategy
      .AddAttribute("PlacementPolicy",
                    "Placement Policy",
                    UintegerValue(0),
                    MakeUintegerAccessor(&PDRMStrategy::m_placementPolicy),
                    MakeUintegerChecker<uint32_t>())

      .AddAttribute("VicinitySize",
                    "Vicinity size",
                    UintegerValue(2),
                    MakeUintegerAccessor(&PDRMStrategy::m_vicinitySize),
                    MakeUintegerChecker<uint32_t>())

      .AddAttribute("VicinityTimer",
                    "Period to discover vicinity",
                    StringValue("5s"),
                    MakeTimeAccessor(&PDRMStrategy::m_vicinityTimer),
                    MakeTimeChecker());

  return tid;
}

PDRMStrategy::PDRMStrategy()
{
}

void
PDRMStrategy::StartApplication() 
{
  // add FIB entriy to the application face (so that the application can receive these messages)
  FibHelper::AddRoute(GetNode(), "/vicinity", m_face, 0);

  PDRMCustodian::StartApplication();
}

void
PDRMStrategy::StopApplication()
{
  PDRMCustodian::StopApplication();
}

void
PDRMStrategy::EndGame()
{
}

void
PDRMStrategy::OnInterest(shared_ptr<const Interest> interest)
{
  if (!m_active)
    return;

  Name object = interest->getName();

  if (Name("/hint").isPrefixOf(object) || Name("/vicinity").isPrefixOf(object))
  {
    if (Name("/hint").isPrefixOf(object))
      OnHint(interest);
    else
      OnVicinity(interest);
  }
  else
  {
    PDRMProvider::OnInterest(interest);
  }
}

void
PDRMStrategy::OnHint(shared_ptr<const Interest> interest)
{
  App::OnInterest(interest);

  PDRMStrategySelectors incomingSelectors = interest->getPDRMStrategySelectors();

  // check if the node is the target
  if (incomingSelectors.getNodeId() == GetNode()->GetId())
  {
    Name object = interest->getName().getSubName(1, 2);

    FoundObject(object);
    StoreObject(object);
  }
}

void
PDRMStrategy::OnVicinity(shared_ptr<const Interest> interest)
{
  App::OnInterest(interest);

  Name object = interest->getName().getSubName(1, 2);
  PDRMStrategySelectors incomingSelectors = interest->getPDRMStrategySelectors();
 
  int32_t nodeId = GetNode()->GetId();
  int32_t homeNetwork = m_homeNetwork;
  pair<int32_t, double> preferredLocation = GetPreferredLocation();
  int32_t currentPosition = m_position.x;
  double availability = m_sessionPeriod.GetSeconds() / (m_sessionPeriod.GetSeconds() + m_movementPeriod.GetSeconds() + 0.001);
  bool interested = m_rand->GetValue(0, 1) < m_altruism;
 
  Name dataName = interest->getName();

  // Create the vicinity packet
  shared_ptr<Data> vicinityData = make_shared<Data>();
  vicinityData->setName(dataName);
  vicinityData->setFreshnessPeriod((time::milliseconds) m_freshness.GetMilliSeconds());

  // Create an empty strategy selector for the Vicinity Data packet 
  PDRMStrategySelectors responseSelectors = PDRMStrategySelectors();

  responseSelectors.setNodeId(nodeId);
  responseSelectors.setHomeNetwork(homeNetwork);
  responseSelectors.setPreferredLocation(preferredLocation.first);
  responseSelectors.setTimeSpentAtPreferredLocation(preferredLocation.second);
  responseSelectors.setCurrentPosition(currentPosition);
  responseSelectors.setAvailability(availability);
  responseSelectors.setInterest(interested);

  vicinityData->setContent(responseSelectors.wireEncode());

  // Add signature
  Signature signature;
  SignatureInfo signatureInfo(static_cast< ::ndn::tlv::SignatureTypeValue>(255));

  if (m_keyLocator.size() > 0) {
    signatureInfo.setKeyLocator(m_keyLocator);
  }

  signature.setInfo(signatureInfo);
  signature.setValue(::ndn::nonNegativeIntegerBlock(::ndn::tlv::SignatureValue, m_signature));

  vicinityData->setSignature(signature);

  // Send the packet
  vicinityData->wireEncode();

  m_transmittedDatas(vicinityData, this, m_face);
  m_face->onReceiveData(*vicinityData);
}

void
PDRMStrategy::OnData(shared_ptr<const Data> data)
{
  Name object = data->getName();

  if (Name("/vicinity").isPrefixOf(object))
  {
    App::OnData(data);
    OnVicinityData(data);
  }
  else
  {
    App::OnData(data);

    Name chunk = data->getName();
    Name object = chunk.getPrefix(2);
    uint32_t seqNumber = chunk.at(-1).toSequenceNumber();

    if (m_chunksMap[object][seqNumber])
      return;

    // Calculate the hop count
    int hopCount = 0;
    auto ns3PacketTag = data->getTag<Ns3PacketTag>();
    if (ns3PacketTag != nullptr) {
      FwHopCountTag hopCountTag;
      if (ns3PacketTag->getPacket()->PeekPacketTag(hopCountTag)) {
        hopCount = hopCountTag.Get();
      }
    }

    m_chunkRetrievalDelay(this, chunk, seqNumber, Simulator::Now() - m_chunkFirstRequest[chunk],
      Simulator::Now() - m_chunkLastRequest[chunk], m_chunkRequestCount[chunk], hopCount);

    m_chunkFirstRequest.erase(chunk);
    m_chunkLastRequest.erase(chunk);
    m_chunkRequestCount.erase(chunk);
    m_retxEvent.erase(chunk);

    m_rtt[object]->AckSeq(SequenceNumber32(seqNumber));
    m_chunksMap[object][seqNumber] = true;
    m_chunksDownloaded[object]++;

    if (m_chunksDownloaded[object] == m_objectSize[object])
      ConcludeObjectDownload(object);
  }
}

void
PDRMStrategy::OnVicinityData(shared_ptr<const Data> data)
{
  App::OnData(data);
  Block block = data->getContent();
  block.parse();
  PDRMStrategySelectors incomingSelectors = PDRMStrategySelectors(*block.elements_begin());

  m_vicinity.push_back(incomingSelectors);
}

// CONSUMER ACTIONS

void
PDRMStrategy::ScheduleNextPacket()
{
  if (m_moving)
    return;

  if (m_chunkRequest.size() + m_chunkRetransmission.size() > 0) {
    if (!m_sendEvent.IsRunning()) {
      m_sendEvent = Simulator::ScheduleNow(&PDRMConsumer::SendPacket, this);
    }
  }
}

void
PDRMStrategy::ConcludeObjectDownload(Name object)
{
  AnnouncePrefix(object);
  PDRMConsumer::ConcludeObjectDownload(object);
}

// PRODUCER ACTIONS

void
PDRMStrategy::ProduceObject()
{
  PDRMProducer::ProduceObject();

  if (m_vicinitySize > 0)
  {
    m_pendingReplication.push(m_lastProducedObject);
    ReplicateContent();
  }
}

// STRATEGY ACTIONS

void
PDRMStrategy::ReplicateContent()
{
  if (m_pendingReplication.size() == 0)
    return;

  Name object = m_pendingReplication.front();

  ProbeVicinity(object);
  Simulator::Schedule(m_vicinityTimer, &PDRMStrategy::PushContent, this, object);
}

void
PDRMStrategy::ProbeVicinity(Name object)
{
  m_vicinity.clear();

  // Create the vicinity packet
  Name vicinityName = Name("/vicinity");
  vicinityName.append(object);

  shared_ptr<Interest> vicinity = make_shared<Interest>();
  vicinity->setNonce(m_rand->GetValue(0, std::numeric_limits<uint32_t>::max()));
  vicinity->setName(vicinityName);
  vicinity->setInterestLifetime((time::milliseconds) m_vicinityTimer.GetMilliSeconds());
  vicinity->setScope(m_vicinitySize);
  
  // Send the packet
  vicinity->wireEncode();

  m_transmittedInterests(vicinity, this, m_face);
  m_face->onReceiveInterest(*vicinity);
}

void
PDRMStrategy::PushContent(Name object)
{
  if (m_moving)
    return;

  //ranked 
  if (!m_placementPolicy)
    PushToSelectedDevices(object);
  //random
  else
    PushToRandomDevices(object);

  m_pendingReplication.pop();
  ReplicateContent();
}

void
PDRMStrategy::PushToSelectedDevices(Name object)
{
  // figure out if object is underprovisioned
  ContentObject properties = m_catalog->getObject(object);
  m_userAvailability = m_sessionPeriod.GetSeconds() / (m_sessionPeriod.GetSeconds() + m_movementPeriod.GetSeconds() + 0.001);

  // if underprovisioned, send at least 1 copy
  // otherwise, do not send to avoid wasting resources
  if (m_userAvailability > properties.availability)
    return;

  // discover how many devices are in fact interested
  // and map interested consumers to location
  map<uint32_t, uint32_t> consumerDistribution;

  m_consumers.clear();
  for (uint32_t i = 0; i < m_vicinity.size(); i++)
  {
    if (m_vicinity[i].getInterest())
    {
      m_consumers.push_back(m_vicinity[i]);
      uint32_t location = m_vicinity[i].getHomeNetwork();
      if (consumerDistribution.count(location) == 0)
        consumerDistribution[location] = 0;
      consumerDistribution[location]++;
    }
  }

  if (m_consumers.size() == 0)
    return;

  //sort consumers in the vicinity
  for (uint32_t i = 0; i < m_consumers.size()-1; i++)
  {
    for (uint32_t j = i+1; j < m_consumers.size(); j++)
    {
      if (consumerDistribution[m_consumers[j].getHomeNetwork()] >= consumerDistribution[m_consumers[i].getHomeNetwork()]
            && m_consumers[j].getAvailability() > m_consumers[i].getAvailability())
      {
         PDRMStrategySelectors temp = m_consumers[i];
         m_consumers[i] = m_consumers[j];
         m_consumers[j] = temp;
      }
    }
  }

  for (uint32_t i = 0; i < m_consumers.size(); i++)
    NS_LOG_DEBUG("Node " << m_consumers[i].getNodeId() << " has location/availability/interest " << m_consumers[i].getHomeNetwork() << "/" <<  m_consumers[i].getAvailability() << "/" << m_consumers[i].getInterest());

  // calculate the percentage of interested consumers
  double interest = (double) m_consumers.size() / (double) m_vicinity.size();
  uint32_t popularLocation = m_consumers.front().getHomeNetwork();

  // select the device in the popular area with the closest availability to meet the requirements
  double requiredAvailability = 1 - ((1-properties.availability) / m_userAvailability);

  PDRMStrategySelectors provider = SelectBestDevice(popularLocation, true, requiredAvailability);
  HintContent(provider.getNodeId(), object);

  // check if requirements are met and object is unpopular, then send another
  double providersAvailability = 1 - ((1-m_userAvailability) * (1-provider.getAvailability()));
  if (interest < 0.1 && properties.availability > providersAvailability)
  {
    // select the device not in the popular area with the closest availability to meet the requirements
    requiredAvailability = 1 - ((1-properties.availability) / providersAvailability);

    provider = SelectBestDevice(popularLocation, false, requiredAvailability);
    HintContent(provider.getNodeId(), object);
  }
}

void
PDRMStrategy::PushToRandomDevices(Name object)
{
  // figure out if object is underprovisioned
  ContentObject properties = m_catalog->getObject(object);
  m_userAvailability = m_sessionPeriod.GetSeconds() / (m_sessionPeriod.GetSeconds() + m_movementPeriod.GetSeconds() + 0.001);

  // if underprovisioned, send only 1 copy, we dont have extra info in the random scenario
  // otherwise, do not send to avoid wasting resources
  if (properties.availability > m_userAvailability)
    return;

  m_consumers.clear();
  for (uint32_t i = 0; i < m_vicinity.size(); i++)
  {
    if (m_vicinity[i].getInterest())
    {
      m_consumers.push_back(m_vicinity[i]);
    }
  }

  PDRMStrategySelectors provider = m_consumers.front();
  HintContent(provider.getNodeId(), object);
}

PDRMStrategySelectors
PDRMStrategy::SelectBestDevice(uint32_t location, bool include, double availability)
{
  PDRMStrategySelectors selection = m_consumers.front();

  // find a device in the given location
  if (include)
  {
    for (uint32_t i = 0; i < m_consumers.size(); i++)
    {
      if (m_consumers[i].getHomeNetwork() == location)
      {
        // since it is ordered, the next one will always have a closer availability to the requirement
        // until it is negative (does not meet). Then we return it.
        if (m_consumers[i].getAvailability() < availability)
          return selection;
        selection = m_consumers[i];
      }
    }
  }
  // find a device not in the location
  else
  {
    for (uint32_t i = 0; i < m_consumers.size(); i++)
    {
      if (m_consumers[i].getHomeNetwork() != location)
      {
        if (m_consumers[i].getAvailability() < availability)
        {
          // the first device may not meet the requirements. Then, send it anyway instead of the first overall
          if (selection == m_consumers.front())
            selection = m_consumers[i];
          return selection;
        }
        selection = m_consumers[i];
      }
    }
  }
  return selection;
}

void
PDRMStrategy::HintContent(int deviceId, Name object)
{
  // Create the vicinity packet
  Name hintName = Name("/hint");
  hintName.append(object);

  shared_ptr<Interest> hint = make_shared<Interest>();
  hint->setNonce(m_rand->GetValue(0, std::numeric_limits<uint32_t>::max()));
  hint->setName(hintName);
  hint->setInterestLifetime((time::milliseconds) m_hintTimer.GetMilliSeconds());
  hint->setScope(m_vicinitySize);
  hint->setNodeId(deviceId);

  // Send the packet
  hint->wireEncode();

  m_transmittedInterests(hint, this, m_face);
  m_face->onReceiveInterest(*hint);
}

// MOBILITY ACTIONS

void
PDRMStrategy::Session(Ptr<const MobilityModel> model)
{
  PDRMMobileProducer::Session(model);

  if (m_pendingReplication.size() > 0)
    Simulator::ScheduleNow(&PDRMStrategy::ReplicateContent, this);

  if (m_chunkRequest.size() + m_chunkRetransmission.size() > 0)
    Simulator::ScheduleNow(&PDRMStrategy::ScheduleNextPacket, this);

}

// This is equal to PDRMMobileProducer, but the Session part is different
void
PDRMStrategy::CourseChange(Ptr<const MobilityModel> model)
{
  if (m_moving)
    Session(model);
  else
    Move(model);

  m_lastMobilityEvent = Simulator::Now();
  m_userAvailability = m_sessionPeriod.GetSeconds() / (m_sessionPeriod.GetSeconds() + m_movementPeriod.GetSeconds() + 0.001);
  m_mobilityEvent(this, m_moving, m_homeNetwork, m_position.x, m_userAvailability);

  NS_LOG_INFO(m_position.x);

  ndn::GlobalRoutingHelper::CalculateRoutes();  
}

} // namespace ndn
} // namespace ns3


